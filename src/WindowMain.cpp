/*************************************/
/* WindowMain based on BWindow class */
/* Created : 24/2/2003 - 18:6:8      */
/* Code Generated by MeTOS           */
/*************************************/

/* USBCommander - USB device information aid
 * Copyright (c) 2003 Dan Pidcock
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include "WindowMain.h"

#include <stdio.h>
#include <String.h>
#include <ListItem.h>
#include <Application.h>

#include "Messages.h"
#include "USBKit.h"
#include "DevListItem.h"
#include "WindowInfo.h"

#define	INFO_BUTTON	'INFO'

// constants fo window layout
const float			kInset = 5.0;
const float			kButtonInfoWidth = 70.0;
const float			kButtonInfoHeight = 20.0;

/***** Constructor ****/
WindowMain::WindowMain(BRect frame,const char *title,window_look look,window_feel feel,uint32 flags,uint32 workspace)
: BWindow(frame,title,look,feel,flags,workspace)
{
	// Allocate objects
	fButtonInfo = new BButton(
					BRect(300+kInset, kInset, 300+kInset+kButtonInfoWidth, kInset+kButtonInfoHeight),
					"ButtonInfo", 
					"Show Info",
					new BMessage(INFO_BUTTON), 
					B_FOLLOW_RIGHT, 
					B_WILL_DRAW | B_NAVIGABLE
					);
					
	fListView = new BListView(
					BRect(kInset, kInset, 300-B_V_SCROLL_BAR_WIDTH, 150),
					"ListView1",
					B_SINGLE_SELECTION_LIST,
					B_FOLLOW_ALL_SIDES
					);
					
	fScrollListView = new BScrollView(
					  "ScrollListView", 
					  fListView, 
					  B_FOLLOW_ALL_SIDES, 
					  0, 
					  false, 
					  true, 
					  B_FANCY_BORDER
					  );
	// Add objects
	AddChild(fButtonInfo);
	AddChild(fScrollListView);
}

/***** QuitRequested ****/
bool WindowMain::QuitRequested()
{
	be_app->PostMessage(B_QUIT_REQUESTED);
	return BWindow::QuitRequested();
}

void WindowMain::MessageReceived(BMessage* message)
{
	USBDevice *dev;
	
	switch(message->what)
	{
		case INFO_BUTTON:
			puts("info");
			int32 selected;
			selected = fListView->CurrentSelection();
			printf("selected=%ld\n", selected);
			dev = (USBDevice *)fDevList.ItemAt(selected);
			WindowInfo *winInfo;
			winInfo = new WindowInfo(BRect(150.00,150.00,600.00,300.00),"USB Device Info", dev, B_DOCUMENT_WINDOW_LOOK, B_NORMAL_WINDOW_FEEL,B_NOT_ZOOMABLE,0);
			winInfo->Show();
			break;

		case DEVICE_ADDED:
			// Add the device to the ListView and also the DevList that mirrors it
			puts("Win: Device added");
			if (message->FindPointer("device", (void **)&dev) == B_OK)
				if (dev)
				{
					fListView->AddItem(new DevListItem(dev));
					printf("Adding item at %ld\n", fListView->CountItems()-1);
					fDevList.AddItem(dev, fListView->CountItems()-1);
				}
				else
					// Strange - but it is safe to do nothing
					puts("dev is null\n");
			break;
			
		case DEVICE_REMOVED:
			// Need to remove the device from the fListView and fDevList
			puts("Win: Device removed");
			// First get the device from the message
			if (message->FindPointer("device", (void **)&dev) == B_OK)
			if (dev)
			{
				// Get the item index from the device list
				int32 itemIndex = fDevList.IndexOf((void *)dev);
				// and remove it from both lists
				printf("remove device at index %ld\n", itemIndex);
				fDevList.RemoveItem(itemIndex);
				fListView->RemoveItem(itemIndex);
			}
			else
				// oh dear
				puts("dev is null\n");
			
			break;
			
		default:
			//printf("WindowMain::MessageReceived %ld\n", message->what);
			BWindow::MessageReceived(message);			
	}
}

